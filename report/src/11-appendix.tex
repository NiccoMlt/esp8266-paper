% chktex-file 26
\appendix

\renewcommand{\thesection}{\Alph{section}}
\renewcommand{\thesubsection}{A.\arabic{subsection}}

\addcontentsline{toc}{section}{Appendice}
\section*{Appendice}

% Laddove necessario è possibile avvalersi di appendici alla relazione per includere materiale di approfondimento.\\

% A titolo esemplificativo possono essere incluse le schede tecniche dei componenti adottati, la normativa di riferimento che regola un particolare dominio applicativo, ecc.

\subsection{Configurazione del Raspberry Pi}\label{app:raspi}

Si è scelto di utilizzare un modulo WiFi USB in aggiunta a quello integrato nel Raspberry Pi 3,
ma è possibile utilizzare il solo modulo WiFi integrato sia come access point che come client, pur con maggiori instabilità e minori velocità.

La procedura di adattamento dell'immagine è stata documentata in modo da poter essere riproducibile in futuro.

\begin{enumerate}
  \item
    La base dell'immagine è l'ultima versione di \textbf{Raspbian} nella sua versione minimale \textbf{lite}:
    in questo caso, la versione Buster del 26 settembre 2019.

    Dopo l'installazione, sono stati aggiornati i pacchetti tramite \texttt{apt} via rete WiFi;
  \item
    seguendo la documentazione fornita sul sito ufficiale\footnote{\url{https://raspap.com/}},
    è stato installato \textbf{RaspAP} e configurato per funzionare esclusivamente via WiFi:
    \begin{enumerate}
      \item
        \texttt{curl -sL https://install.raspap.com | bash} permette di installare RaspAP\@;
      \item
        seguendo le FAQ\footnote{\url{https://github.com/billz/raspap-webgui/wiki/FAQs\#can-i-use-wlan0-and-wlan1-rather-than-eth0-for-my-ap}}
        al file \texttt{includes/config.php} si è aggiunta \texttt{wlan1} come client interface e si è impostato nel file \texttt{/etc/dhcpcd.conf}
        \texttt{wlan0} come access point
    \end{enumerate}
    In questo modo, il dispositivo dovrebbe essere in grado di collegarsi alla rete WiFi pre-configurata e mettere a disposizione una rete con SSID ``raspi-webgui''.
  \item
    utilizzando lo script ufficiale\footnote{\url{https://github.com/docker/docker-install}} si è installato Docker;
  \item
    si è installato Java 1.8 tramite pacchetto \texttt{openjdk-8-jdk-headless};
  \item
    il broker MQTT Mosquitto viene eseguito tramite container Docker \texttt{eclipse-mosquitto}.
\end{enumerate}

\subsection{Procedura di deploy su Google App Engine in \emph{flexible environment}}\label{app:gcp}

Come detto\improvement{Inserire riferimento alla sezione corretta}, % TODO
il progetto si appoggia all'ambiente App Engine della Google Cloud Platform per l'hosting del backend cloud.

Di seguito è riportata la procedura per effettuare il deploy tramite interfaccia a linea di comando.

\begin{enumerate}
  \item
    assicurarsi di avere installato \textbf{Java} e il \textbf{Google Cloud SDK} e di essere autenticati in quest'ultimo.
  \item
    generare l'uberJar da includere nell'immagine tramite Gradle:
    \begin{minted}[autogobble]{bash}
      ./gradlew clean build shadowJar
    \end{minted}
    Verrà generato un file \texttt{build/libs/crowd-sensor-cloud-backend-all.jar}.
  \item
    nella root del sottoprogetto relativo al backend cloud, sono presenti due file:
    \begin{itemize}
      \item
        Il file \texttt{app.yaml} è la configurazione che definisce l'ambiente di esecuzione.
        \inputminted[fontsize=\footnotesize,frame=lines,linenos]{yaml}{../cloud-backend/app.yaml}
        Si è scelto di utilizzare il \emph{flexible environment} con \emph{runtime} Docker.
      \item Il file \texttt{keyfile.json}, non tracciato, contiene le credenziali per l'accesso al database.
      \begin{minted}[autogobble,fontsize=\footnotesize,frame=lines,linenos]{json}
        {
          "type": "service_account",
          "project_id": "wifi-crowd-sensor-system",
          "private_key_id": "<ID della chiave privata>",
          "private_key": "<chiave privata>",
          "client_email": "<email account di servizio>",
          "client_id": "<ID del client>",
          "auth_uri": "https://accounts.google.com/o/oauth2/auth",
          "token_uri": "https://oauth2.googleapis.com/token",
          "auth_provider_x509_cert_url": "<Provider x509 di Google>",
          "client_x509_cert_url": "<URL ai certificati x509>"
        }
      \end{minted}
      \item
        Il \texttt{Dockerfile} definisce una \emph{runtime} per eseguire \texttt{verticle} di Vert.x.
        \inputminted[fontsize=\footnotesize,frame=lines,linenos]{dockerfile}{../cloud-backend/Dockerfile}
    \end{itemize}
    Tali file saranno individuati automaticamente invocando:
    \begin{minted}[autogobble]{bash}
      gcloud app deploy --project wifi-crowd-sensor-system
    \end{minted}
  \item
    Tramite il comando \mintinline{bash}{gcloud app browse} verrà aperto il link alla web UI del progetto:
    \url{http://wifi-crowd-sensor-system.appspot.com}
\end{enumerate}
